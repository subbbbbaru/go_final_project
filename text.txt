

Приступаем к итоговому заданию
В итоговом задании вам нужно написать на Go веб-сервер, который реализует функциональность простейшего планировщика задач. Это будет аналог TODO-листа. Это задание на проверку и закрепление навыков по написанию веб-сервера, работе с REST API и базами данных. 
На выполнение итогового задания отводится два спринта. Чтобы упорядочить работу, мы разбили его на шаги. На каждый шаг отведён один урок, где есть постановка текущей задачи с объяснениями, комментариями и подсказками. Если что-то из материалов задания будет непонятно, попробуйте поискать ответ в интернете или обратитесь за помощью к наставникам. Сторонними библиотеками пользоваться можно, но помните: изучение нового пакета займёт время. Возможно, проще будет использовать стандартную библиотеку.  
Что должен делать планировщик
Планировщик хранит задачи, каждая из них содержит дату дедлайна и заголовок с комментарием. Задачи могут повторяться по заданному правилу: например, ежегодно, через какое-то количество дней, в определённые дни месяца или недели. Если отметить такую задачу как выполненную, она переносится на следующую дату в соответствии с правилом. Обычные задачи при выполнении будут просто удаляться. 
API содержит следующие операции:
	•			добавить задачу;
	•			получить список задач;
	•			удалить задачу;
	•			получить параметры задачи;
	•			изменить параметры задачи;
	•			отметить задачу как выполненную.
Проверка сервера и тесты
Работу сервера вы сможете контролировать в браузере. У вас будет готовый фронтенд: html, css, js-файлы, и вы сможете сразу проверить работу приложения в браузере. Фронтенд отправляет на сервер API-запросы, вам нужно будет реализовать их обработку по техническому заданию. Если обработчики будут написаны правильно, фронтенд должен работать без ошибок. 
Кроме этого, у вас будет доступ к тестам для проверки кода. Прохождение тестов — это минимальное условие для передачи кода на проверку.
Задачи со звёздочкой
В уроках вам встретятся задачи со звёздочкой. Выполнять их не обязательно, поэтому ориентируйтесь на свои силы. Дополнительные задачи не сильно сложные, но времени они всё же потребуют. Можете сначала написать сервер в минимальной конфигурации, а затем, если останется время, вернуться к задачам со звёздочкой.
Вводная часть закончилась. Переходим к практике.
Склонируйте или скачайте репозиторий go_final_project. В нём есть директория tests с тестами для проверки сервера и директория web с файлами фронтенда. Возьмите файлы этого репозитория за основу, в главной директории создайте модуль Go и файл main.go. Дальше на каждом шаге добавляйте сюда нужные обработчики и функции. Можно сразу продумать, как будет организован ваш код: можно разбивать его на пакеты или только на файлы рядом с main.go. В любом случае, не пихайте всё в один файл. Ревьюер вернёт проект на доработку, если не поймёт, чПриступаем к итоговому заданию
В итоговом задании вам нужно написать на Go веб-сервер, который реализует функциональность простейшего планировщика задач. Это будет аналог TODO-листа. Это задание на проверку и закрепление навыков по написанию веб-сервера, работе с REST API и базами данных. 
На выполнение итогового задания отводится два спринта. Чтобы упорядочить работу, мы разбили его на шаги. На каждый шаг отведён один урок, где есть постановка текущей задачи с объяснениями, комментариями и подсказками. Если что-то из материалов задания будет непонятно, попробуйте поискать ответ в интернете или обратитесь за помощью к наставникам. Сторонними библиотеками пользоваться можно, но помните: изучение нового пакета займёт время. Возможно, проще будет использовать стандартную библиотеку.  
Что должен делать планировщик
Планировщик хранит задачи, каждая из них содержит дату дедлайна и заголовок с комментарием. Задачи могут повторяться по заданному правилу: например, ежегодно, через какое-то количество дней, в определённые дни месяца или недели. Если отметить такую задачу как выполненную, она переносится на следующую дату в соответствии с правилом. Обычные задачи при выполнении будут просто удаляться. 
API содержит следующие операции:
	•			добавить задачу;
	•			получить список задач;
	•			удалить задачу;
	•			получить параметры задачи;
	•			изменить параметры задачи;
	•			отметить задачу как выполненную.
Проверка сервера и тесты
Работу сервера вы сможете контролировать в браузере. У вас будет готовый фронтенд: html, css, js-файлы, и вы сможете сразу проверить работу приложения в браузере. Фронтенд отправляет на сервер API-запросы, вам нужно будет реализовать их обработку по техническому заданию. Если обработчики будут написаны правильно, фронтенд должен работать без ошибок. 
Кроме этого, у вас будет доступ к тестам для проверки кода. Прохождение тестов — это минимальное условие для передачи кода на проверку.
Задачи со звёздочкой
В уроках вам встретятся задачи со звёздочкой. Выполнять их не обязательно, поэтому ориентируйтесь на свои силы. Дополнительные задачи не сильно сложные, но времени они всё же потребуют. Можете сначала написать сервер в минимальной конфигурации, а затем, если останется время, вернуться к задачам со звёздочкой.
Вводная часть закончилась. Переходим к практике.
Склонируйте или скачайте репозиторий go_final_project. В нём есть директория tests с тестами для проверки сервера и директория web с файлами фронтенда. Возьмите файлы этого репозитория за основу, в главной директории создайте модуль Go и файл main.go. Дальше на каждом шаге добавляйте сюда нужные обработчики и функции. Можно сразу продумать, как будет организован ваш код: можно разбивать его на пакеты или только на файлы рядом с main.go. В любом случае, не пихайте всё в один файл. Ревьюер вернёт проект на доработку, если не поймёт, что и где у вас находится. 
Тесты запускаются из основной директории. Перед запуском тестов проверьте, что ваш веб-сервер работает.
Шаг 1. Запускаем веб-сервер
Сначала нужно создать минимальный веб-сервер, который будет слушать определённый порт и возвращать запрашиваемые файлы фронтенда. По умолчанию сервер должен слушать порт 7540. Если вы хотите использовать другой порт, укажите его в переменной Port в файле tests/settings.go. Или же нужно определить переменную окружения TODO_PORT с  соответствующим значением.
Сервер при запросе http://localhost:7540/ должен возвращать index.html из поддиректории web. Главная страница запрашивает .js и .css файлы, поэтому веб-сервер также должен их возвращать. Например:
	•			http://localhost:7540/js/scripts.min.js возвращает ./web/js/scripts.min.js;
	•			http://localhost:7540/css/style.css возвращает ./web/css/style.css;
	•			http://localhost:7540/favicon.ico возвращает ./web/favicon.ico.
По сути, на этом шаге нужно реализовать простейший файл-сервер. Сделать это не сложнее, чем создать обработчик событий. Этот пример будет возвращать файлы из поддиректории, имя которой хранится в переменной webDir:

http.Handle("/", http.FileServer(http.Dir(webDir))) 

Там может быть указан как абсолютный, так и относительный путь.
Для проверки запустите go test -run ^TestApp$ ./tests. Если тест завершился успешно, можете открыть в браузере http://localhost:7540/.
Задание со звёздочкой
Реализуйте возможность определять извне порт при запуске сервера. Если существует переменная окружения TODO_PORT, сервер при старте должен слушать порт со значением этой переменной. 
Получить значение переменной окружения поможет функция os.Getenv(key string) string.то и где у вас находится. 
Тесты запускаются из основной директории. Перед запуском тестов проверьте, что ваш веб-сервер работает.
Шаг 1. Запускаем веб-сервер
Сначала нужно создать минимальный веб-сервер, который будет слушать определённый порт и возвращать запрашиваемые файлы фронтенда. По умолчанию сервер должен слушать порт 7540. Если вы хотите использовать другой порт, укажите его в переменной Port в файле tests/settings.go. Или же нужно определить переменную окружения TODO_PORT с  соответствующим значением.
Сервер при запросе http://localhost:7540/ должен возвращать index.html из поддиректории web. Главная страница запрашивает .js и .css файлы, поэтому веб-сервер также должен их возвращать. Например:
	•			http://localhost:7540/js/scripts.min.js возвращает ./web/js/scripts.min.js;
	•			http://localhost:7540/css/style.css возвращает ./web/css/style.css;
	•			http://localhost:7540/favicon.ico возвращает ./web/favicon.ico.
По сути, на этом шаге нужно реализовать простейший файл-сервер. Сделать это не сложнее, чем создать обработчик событий. Этот пример будет возвращать файлы из поддиректории, имя которой хранится в переменной webDir:

http.Handle("/", http.FileServer(http.Dir(webDir))) 

Там может быть указан как абсолютный, так и относительный путь.
Для проверки запустите go test -run ^TestApp$ ./tests. Если тест завершился успешно, можете открыть в браузере http://localhost:7540/. 

Задание со звёздочкой
Реализуйте возможность определять извне порт при запуске сервера. Если существует переменная окружения TODO_PORT, сервер при старте должен слушать порт со значением этой переменной. 
Получить значение переменной окружения поможет функция os.Getenv(key string) string.

Шаг 2. Проектируем и создаём БД
Вам же охота сохранять созданные в TODO-листе задачи? Тогда нужно спроектировать и создать базу данных для хранения задач. Для этого будет использоваться база данных SQLite. Других сущностей, кроме задач, не планируется, поэтому будет достаточно одной таблицы. Помимо веб-сервера базу данных могут использовать другие утилиты, поэтому принято решение дать имена таблице и её полям. Файл базы данных scheduler.db должен содержать таблицу scheduler с такими колонками:
	•			id — автоинкрементный идентификатор;
	•			date — дата задачи, которая будет хранится в формате YYYYMMDD или в Go-представлении 20060102;
	•			title — заголовок задачи;
	•			comment — комментарий к задаче;
	•			repeat — строковое поле не более 128 символов, которое будет содержать правила повторений для задачи. Формат правил будет описан в следующем шаге.
Выберите подходящие типы для полей самостоятельно. Задачи должны будут возвращаться отсортированными по дате, поэтому не забудьте создать индекс по полю date. 
Сделайте так, чтобы при запуске сервер проверял, существует ли в директории приложения файл scheduler.db. Если его нет, следует создать базу данных с таблицей scheduler. Вот пример кода, который определяет директорию приложения и проверяет, есть ли в ней нужный файл:

appPath, err := os.Executable()
if err != nil {
    log.Fatal(err)
}
dbFile := filepath.Join(filepath.Dir(appPath), "scheduler.db")
_, err = os.Stat(dbFile)

var install bool
if err != nil {
    install = true
}
// если install равен true, после открытия БД требуется выполнить 
// sql-запрос с CREATE TABLE и CREATE INDEX 

Для проверки запустите go test -run ^TestDB$ ./tests. По умолчанию тест считает, что файл с базой данных scheduler.db находится в родительской директории. Вы можете указать другой путь в значении переменной DBFile в файле ./tests/settings.go. Или можно определить переменную окружения TODO_DBFILE и хранить путь к базе данных там.
Если тест выполнился успешно, можно переходить к следующему шагу.
Задание со звёздочкой
Реализуйте возможность определять путь к файлу базы данных через переменную окружения. Для этого сервер должен получать значение переменной окружения TODO_DBFILE и использовать его в качестве пути к базе данных, если это не пустая строка.

Шаг 3. Правила повторения задач
Загрузка фронтенда есть, создание SQlite БД имеется. Но прежде чем реализовывать обработчики API-запросов, необходимо написать функцию, которая будет вычислять следующую дату для задачи в соответствии с указанным правилом. Пожалуй, это самая сложная часть итогового задания. Поэтому мы разбили правила на две группы: базовые и со звёздочкой. Работу базовых правил реализовать обязательно — это минимум. Но будет отлично, если вы напишите поддержку для всех правил.
Правила повторения задач хранятся в колонке repeat. Ниже перечислены базовые правила.
	•			Если правило не указано, отмеченная выполненной задача будет удаляться из таблицы;
	•			d <число> — задача переносится на указанное число дней. Максимально допустимое число равно 400. Примеры:
	•			 
	•			d 1 — каждый день;
	•			d 7 — для вычисления следующей даты добавляем семь дней;
	•			d 60 — переносим на 60 дней.
	•			y — задача выполняется ежегодно. Этот параметр не требует дополнительных уточнений. При выполнении задачи дата перенесётся на год вперёд.
Правила со звёздочкой идут ниже, их реализация будет немного посложнее.
	•			w <через запятую от 1 до 7> — задача назначается в указанные дни недели, где 1 — понедельник, 7 — воскресенье. Например: 
	•			 
	•			w 7 — задача перенесётся на ближайшее воскресенье;
	•			w 1,4,5 — задача перенесётся на ближайший понедельник, четверг или пятницу;
	•			w 2,3 — задача перенесётся на ближайший вторник или среду.
	•			m <через запятую от 1 до 31,-1,-2> [через запятую от 1 до 12] — задача назначается в указанные дни месяца. При этом вторая последовательность чисел опциональна и указывает на определённые месяцы. Например:
	•			 
	•			m 4 — задача назначается на четвёртое число каждого месяца;
	•			m 1,15,25 — задача назначается на 1-е, 15-е и 25-е число каждого месяца;
	•			m -1 — задача назначается на последний день месяца;
	•			m -2 — задача назначается на предпоследний день месяца;
	•			m 3 1,3,6 — задача назначается на 3-е число января, марта и июня;
	•			m 1,-1 2,8 — задача назначается на 1-е и последнее число число февраля и авгуcта.
Рекомендуем реализовать примерно такую функцию:

func NextDate(now time.Time, date string, repeat string) (string, error) 

с параметрами:
	•			now — время от которого ищется ближайшая дата;
	•			date — исходное время в формате 20060102, от которого начинается отсчёт повторений;
	•			repeat — правило повторения в описанном выше формате.
Функция возвращает следующую дату в формате 20060102 и ошибку. Возвращаемая дата должна быть больше даты, указанной в переменной now.
Для закрепления посмотрите на примеры. Если предположить, что сегодня 26.01.2024, тогда:
	•			NextDate(now, "20240229", "y") возвращает  20250301;
	•			NextDate(now, "20240113", "d 7") возвращает  20240127;
	•			NextDate(now, "20240116", "m 16,5") возвращает  20240205;
	•			NextDate(now, "20240201", "m -1,18") возвращает  20240218;
Функция должна возвращать ошибки при некорректных датах или если формат правила повторения не соблюден. Например, ошибка должна возвращаться в следующих случаях:
	•			в колонкеrepeat — пустая строка;
	•			время в переменной date не может быть преобразовано в корректную дату — ошибка выполнения time.Parse("20060102", d);
	•			указан неверный формат repeat.
Вот примеры неправильных форматов:
	•			l 34 — недопустимый символ;
	•			d — не указан интервал в днях;
	•			d 405 — превышен максимально допустимый интервал;
	•			w 8 — недопустимое значение 8;
	•			m 4,40 — недопустимый день месяца;
	•			m 5 1,13 — недопустимый месяц.
Если вы реализуете только базовые правила d и y и не выполняете распознавание форматов w ... и m ..., тогда при получении таких строк просто возвращайте ошибку — например, неподдерживаемый формат.
На следующем шаге уже начнётся реализация API-обработчиков. Для подготовки следует немного размяться. Добавьте к серверу GET-обработчик api/nextdate, который должен принимать запросы в таком формате: "/api/nextdate?now=<20060102>&date=<20060102>&repeat=<правило>". Например: "api/nextdate?now=20240126&date=20240126&repeat=y". При этом в обработчике нужно будет вызвать созданную вами функцию и вернуть дату следующего выполнения в формате 20060102 или текст ошибки.
Когда вы напишите функцию и обработчик /api/nextdate, для проверки запустите go test -run ^TestNextDate$ ./tests. Если вы реализовали поддержку всех вариантов правил повторения, предварительно присвойте true значению переменной FullNextDate в файле tests/settings.go. Тогда тест проверит правила для недель и месяцев.
Советы по решению
Чтобы реализовать требуемый функционал, не нужно придумывать хитрые алгоритмы. Есть полезная функция time.AddDate(), которая добавляет ко времени указанное количество лет, месяцев и дней. Например, для правила d <дни> достаточно в цикле вызывать AddDate( 0, 0, <дни>) до тех пор, пока дата не станет больше времени now.
Если речь идёт о днях недели или месяца, определите мапу допустимых значений и затем день за днём проверяйте получаемые даты с помощью AddDate(0, 0, 1). Это только один вариант реализации. Вполне возможно, что вы сможете придумать свой простой и эффективный алгоритм.
Для получения GET-параметров (now, date, repeat) в обработчике можно использовать метод (r *Request) FormValue(key string) string из пакета net/http.


Шаг 4. Добавляем задачу
Вы уже наверняка попробовали нажать на кнопку Добавить задачу на странице сервера в браузере. 

К сожалению, при сохранении выводится ошибка: фронтенд отправляет запрос по адресу /api/task, но такой обработчик ещё не реализован. Пришла пора это сделать.
Добавьте в веб-сервер POST-обработчик /api/task, который будет добавлять задачу в базу данных. Запрос и ответ передаются в JSON-формате. Запрос состоит из следующих строковых полей:
	•			date — дата задачи в формате 20060102;
	•			title — заголовок задачи. Обязательное поле;
	•			comment — комментарий к задаче;
	•			repeat — правило повторения. Используется такой же формат, как в предыдущем шаге.
Примеры запросов:

{
  "date": "20240201",
  "title": "Подвести итог",
  "comment": "Мой комментарий",
  "repeat": "d 5"
} 


{
  "date": "20240202",
  "title": "Сходить зоопарк",
  "repeat": ""
} 

Поле title обязательное. Еще обязательно проверьте, что дата указана в формате 20060102 и что функция time.Parse() корректно её распознаёт. Если поле date не указано или содержит пустую строку, берётся сегодняшнее число. Если дата меньше сегодняшнего числа, есть два варианта:
	•			если правило повторения не указано или равно пустой строке, подставляется сегодняшнее число;
	•			при указанном правиле повторения вам нужно вычислить и записать в таблицу дату выполнения, которая будет больше сегодняшнего числа. Для этого используйте функцию NextDate(), которую вы уже написали раньше.
На самом деле, если правило повторения указано, его нужно проверить в любом случае. Делать это можно вызовом всё той же функции NextDate(). Поэтому проще сразу вычислить следующую от сегодняшней дату и использовать её, если дата задачи меньше сегодняшней.
Обработчик должен возвращать JSON с полем id или error. В случае успеха возвращается идентификатор созданной записи, а в случае ошибки — текст ошибки.

{"id":"186"} 


{"error":"Не указан заголовок задачи"} 

Вот в каких случаях должны возвращаться ошибки:
	•			ошибка десериализации JSON;
	•			не указан заголовок задачи;
	•			дата представлена в формате, отличном от 20060102;
	•			правило повторения указано в неправильном формате.
Если вы реализовали поддержку только базовых правил, попытка добавить еженедельную или ежемесячную задачу тоже должна возвращать ошибку.
Где-то можно возвращать ошибки функций стандартной библиотеки — например, ошибку десериализации. В других случаях придумайте текст ошибки самостоятельно. Тесты не требуют конкретных текстов для ошибок.
Для проверки запустите тест go test -run ^TestAddTask$ ./tests. Если тест прошёл успешно, можете попробовать добавить задачу в браузере. Нажмите на кнопку Добавить задачу и укажите нужные параметры. Отображение текущих задач ещё не реализовано, поэтому после добавления задачи ничего не изменится. Результат можно проверить с помощью любой утилиты по просмотру базы данных SQLite. Добавленные задачи должны присутствовать в таблице scheduler.
На следующем шаге вам предстоит реализовать обработчик, который будет возвращать список ближайших задач. После этого добавленные задачи будут отображаться сразу на странице.
Советы по решению
Обратите внимание, что вы должны добавлять задачу только в том случае, если запрос был отправлен методом POST. Дело в том, что к одному запросу /api/task будет привязано несколько действий, которые используют разные методы. Например, получение информации о задаче — GET-запрос /api/task?id=<число>, удаление задачи — DELETE-запрос /api/task?id=<число>. Поэтому в функции обработчика /api/task можно вставить switch, который будет вызывать разные функции в зависимости от используемого HTTP-метода.
Чтобы получить идентификатор созданной задачи, используйте значение типа Result. Его возвращают методы Exec() и ExecContext(). Пример кода:

res, err := db.Exec(query, task.Date, task.Title, task.Comment, task.Repeat)
if err != nil {
    // ...
}
id, err := res.LastInsertId()
// ... 

В ответе вы отправляете JSON-данные, поэтому не забудьте добавлять соответствующий заголовок:

w.Header().Set("Content-Type", "application/json; charset=UTF-8") 


Шаг 5. Получаем список ближайших задач
Сейчас ваш бэкенд уже может добавлять задачи в базу данных. К сожалению, пока они не отображаются в браузере. Чтобы это исправить, нужно реализовать обработчик для GET-запроса /api/tasks. Он должен возвращать список ближайших задач в формате JSON в виде списка в поле tasks. Задачи должны быть отсортированы по дате в сторону увеличения. Каждая задача должна содержать все поля таблицы scheduler в виде строк. Дата представлена в уже знакомом вам формате 20060102. Например:

{
    "tasks": [
        {
            "id": "171",
            "date": "20240131",
            "title": "Заголовок задачи",
            "comment": "",
            "repeat": ""
        },
        {
            "id": "176",
            "date": "20240131",
            "title": "Фитнес",
            "comment": "",
            "repeat": "d 3"
        },
        {
            "id": "185",
            "date": "20240201",
            "title": "Подвести итог",
            "comment": "Мой комментарий",
            "repeat": "d 5"
        },
        ...
    ]
} 

Максимальное количество возвращаемых записей не регламентировано, но рекомендуем ограничиться списком от 10 до 50 задач. Если задач нет, возвращается пустой список:

{
    "tasks": []
} 

При ошибке возвращается JSON-объект с полем error.

{"error": "текст ошибки"} 

Для проверки запустите go test -run ^TestTasks$ ./tests. Предупреждаем, что тест предварительно удалит все задачи в таблице scheduler. 

При добавлении задачи список будет автоматически обновляться.
Задание со звёздочкой
В браузере рядом с кнопкой Добавить задачу есть поле для поиска. Добавьте возможность выбрать задачи через строку поиска. Необходимо проверить наличие строки поиска в заголовке или комментарии задач. Обработчик должен дополнительно обрабатывать параметр search в строке запроса. Например, /api/tasks?search=бассейн возвратит задачи со словом «бассейн». Ещё добавьте возможность выбрать задачи на конкретную дату. Для этого нужно проверять search на соответствие формату 02.01.2006. То есть, по запросу /api/tasks?search=08.02.2024 должны возвратиться задачи на 8 февраля 2024 года.

Чтобы протестировать поиск, присвойте переменной Search значение true в файле tests/settings.go и запустите тест go test -run ^TestTasks$ ./tests.
Советы по решению
Чтобы избежать {"tasks":null} в ответе JSON при отсутствии задач, следите за результирующим слайсом. Если он равен nil, нужно создавать пустой слайс.
Для поиска подстроки можно использовать SQL-оператор LIKE. Проверяя работу поиска, учитывайте, что LIKE различает регистр символов. Чтобы избежать SQL-инъекции, не вставляйте напрямую в SQL-запрос строку из параметра search. Вариант запроса при вызове в Go:

SELECT * FROM scheduler WHERE title LIKE ? OR comment LIKE ? ORDER BY date LIMIT ?

-- вариант с именованными параметрами sql.Named()
SELECT * FROM scheduler WHERE title LIKE :search OR comment LIKE :search ORDER BY date LIMIT :limit 

При выборке по дате можно использовать обычное сравнение. Но помните, что дату из формата 02.01.2006 нужно преобразовать в формат 20060102.

SELECT * FROM scheduler WHERE date = ? LIMIT ?

-- вариант с именованными параметрами sql.Named()
SELECT * FROM scheduler WHERE date = :date LIMIT :limit 

Шаг 6. Редактирование задачи
Когда вы наводите мышкой на карточку с задачей, в правом нижнем углу появляются кнопки-иконки для редактирования и удаления задачи, а ещё для отметки о выполнении. Начнём с редактирования. Прежде чем что-то изменять, нужно получить текущие значения. В нашем случае необходимо добавить обработку GET-запроса, который возвратит все параметры задачи по её идентификатору. Если сейчас нажать на иконку редактирования задачи, появится ошибка. Исправьте ситуацию — реализуйте обработчик GET-запроса /api/task?id=<идентификатор>. Запрос должен возвращать JSON-объект со всеми полями задачи. 
Например, результатом запроса /api/task?id=185 может быть:

{
    "id": "185",
    "date": "20240201",
    "title": "Подвести итог",
    "comment": "",
    "repeat": "d 5"
} 

Если при поиске задачи произошла ошибка, нужно вернуть JSON-объект с полем "error". Например:

{"error": "Задача не найдена"}
// или
{"error": "Не указан идентификатор"} 

Для проверки выполните тест go test -run ^TestTask$ ./tests. Если тесты прошли успешно, при нажатии на кнопку редактирования в карточке задачи должны отобразиться её текущие параметры.

Если пользователь изменит какое-либо значение, в диалоговом окне появится кнопка Сохранить. При нажатии на неё фронтенд отправляет значение всех полей методом PUT по адресу /api/task. Данные передаются в виде JSON-объекта, как при добавлении задачи, но с полем id:

{
    "id": "185",
    "date": "20240201",
    "title": "Подвести итог",
    "comment": "",
    "repeat": ""
} 

Добавьте обработку PUT-запроса в хендлер для /api/task. При этом нужно данные нужно проверять так же, как при добавлении задачи. В случае успешного изменения должен возвращаться пустой JSON {}, а в случае ошибки, она записывается в поле error.

{"error":"Задача не найдена"} 

Проверьте, правильно ли вы реализовали обновление параметров задач, запустите тест go test -run ^TestEditTask$ ./tests. 
После проверьте, как работает редактирование задач в браузере.

Шаг 7. Заканчиваем реализацию API
Осталось реализовать два действия — отметка о выполнении и удаление задачи. Задача выполняется, когда пользователь нажимает на кнопку слева от заголовка задачи или на иконку-галочку в правом нижнем углу карточки задачи.

Напишите обработчик для POST-запроса /api/task/done, который делает задачу выполненной. Для периодической задачи нужно рассчитать и поменять дату следующего выполнения. Одноразовая задача с пустым полем repeat удаляется. Идентификатор задачи передаётся в самом запросе /api/task/done?id=<идентификатор>.
В случае успешного удаления возвращается пустой JSON {}, а в случае ошибки, она должна быть указана в поле error.

{"error":"Текст ошибки"} 

Для расчёта следующей даты используйте функцию NextDate() из начала итогового задания. Самое главное, не забудьте изменить у задачи значение колонки date на новую дату.
Для проверки выполните тест go test -run ^TestDone$ ./tests и проверьте новый функционал в браузере.
Удаление задачи
Бывают ситуации, когда задача потеряла актуальность и её нужно просто удалить. На фронтенде в браузере для этого есть иконка в виде корзины. Добавьте в хендлер /api/task обработку запроса с методом DELETE - /api/task/done?id=<идентификатор>. В этом случае нужно удалить из таблицы scheduler задачу с указанным идентификатором.
Ответ сервера должен быть аналогичен ответу на запрос /api/task/done. Нужно возвращать {} или, в случае ошибки, JSON с полем error.
Проверьте функцию удаления задач, как обычно, с помощью тестов go test -run ^TestDelTask$ ./tests, а затем в браузере.
Финальная проверка
Вот вы и закончили написание веб-сервера с требуемым API. Пришла очередь запустить все тесты go test ./tests. Если они прошли успешно — поздравляем! Вы реализовали все API-запросы, которые нужны для работы фронтенда. Понажимайте на кнопочки самостоятельно и проверьте работу фронтенда в браузере: добавьте, измените, удалите задачу и так далее.


Шаг 8. Заключительный, со звёздочкой
Если вы ограничились программированием базового функционала, можно считать, что ваша итоговая работа выполнена и готова к сдаче. В этом уроке будут задания с повышенной сложностью, их можно выполнить по желанию, но в любом случае, дочитайте урок до конца. Рекомендуем перед этим выполнить все предыдущие задания со звёздочкой. Если вы это уже сделали — прекрасно.
Аутентификация
Первое задание — подключить к вашему веб-серверу механизм аутентификации. Предположим, вы хотите сделать доступ к планировщику только по паролю. Чтобы сильно не усложнять задачу и не добавлять таблицу пользователей со всей тянущейся за этим разработкой, можно ограничиться простейшей ситуацией. Пусть пароль хранится в переменной окружения TODO_PASSWORD. Если это значение не пустое — нужно запросить пароль. При этом ваши API-запросы тоже должны проверять, аутентифицирован ли пользователь или нет. Разберём пошагово реализацию аутентификации.
На фронтенде уже заготовлена страница с диалогом для ввода пароля. Откройте её в браузере по пути http://localhost:7540/login.html; ваш порт может отличаться.

Пользователи отсутствуют, поэтому в логине большого смысла нет и форма содержит только поле ввода для пароля. Когда вводится пароль и нажимается кнопка Войти, фронтенд отправляет POST-запрос по адресу /api/sign. Обработчику придёт JSON с полем password, которое содержит введённый пароль. Обратите внимание: в учебном проекте пароль передаётся в открытом виде. Но на практике даже при использовании HTTPS передача пароля таким образом — не лучшее решение. 

{
    "password": "12345"
} 

Реализуйте такой обработчик в вашем веб-сервере. Функция должна сверять указанный пароль с хранимым в переменной окружения TODO_PASSWORD. Если они совпадают, нужно сформировать JWT-токен и возвратить его в поле token JSON-объекта. Если пароль неверный или произошла ошибка, возвращается JSON c текстом ошибки в поле error. 

/* успешная аутентификация */
{
    "token": "eyJhbGciOiJIUzI1NiIsIn...RiTtFvNED9xWfOE"
}
/* ошибочная аутентификация */
{
    "error": "Неверный пароль"
} 

В качестве полезной нагрузки JWT-токена вставьте туда какой-нибудь хэш или контрольную сумму пароля. Если фронтенд увидит ответ с токеном, он добавит куку token со временем жизни 8 часов и откроет главную страницу планировщика. На самом деле механизм простой: из пароля получаем какую-то строку — токен, по которой очень затруднительно восстановить сам пароль. Записываем этот токен в куки, а затем при вызовах API читаем токен из куки и проверяем его на валидность и соответствие паролю. Не так важно, как сформирован токен; главное, чтобы за формирование токена и его валидацию отвечал один и тот же алгоритм. Вам предлагается поработать с JWT-токеном — они используются довольно часто и в курсе был соответствующий урок.
Когда обработчик /api/signin будет реализован, необходимо добавить проверку аутентификации для следующих API-запросов:
	•			/api/task — все поддерживаемые HTTP методы;
	•			/api/tasks — получение списка задач;
	•			/api/task/done — запрос на выполнение задачи.
Лучше всего это сделать, используя механизм middleware. Предположим, что обработчик определялся как http.HandleFunc("/api/task", taskHandler). Тогда добавление промежуточных действий может выглядеть так:

func auth(next http.HandlerFunc) http.HandlerFunc {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // смотрим наличие пароля
        pass := os.Getenv("TODO_PASSWORD")
        if len(pass) > 0 {
            var jwt string  // JWT-токен из куки
            // получаем куку
            cookie, err := r.Cookie("token")
            if err == nil {
                jwt = cookie.Value
            }
            var valid bool
            // здесь код для валидации и проверки JWT-токена
            // ...

            if !valid {
                // возвращаем ошибку авторизации 401
                http.Error(w, "Authentification required", http.StatusUnauthorized)
                return
            }
        }
        next(w, r)
    })
} 

Тогда регистрация обработчика будет такой: http.HandleFunc("/api/task", auth(taskHandler)). Аналогично меняется определение обработчиков для остальных API-запросов. Это только один из вариантов реализации. Обратите внимание:
	•			Проверка аутентификации происходит, только если определён пароль в os.Getenv("TODO_PASSWORD");
	•			Значение куки берётся с помощью r.Cookie("token");
	•			При валидации JWT токена не забудьте сравнить хэш (или контрольную сумму) текущего пароля и его хэш из токена. Если изменился пароль в переменной окружения, проверка токена для старого пароля не может быть валидной;
	•			В случае ошибки аутентификации следует возвращать ошибку http.StatusUnauthorized (код 401). При этой ошибке фронтенд переведёт пользователя на страницу ввода пароля /login.html.
Чтобы запустить тесты go test ./tests для веб-сервера с поддержкой аутентификации, присвойте переменной Token в tests/settings.go значение токена, которое сервер возвратил из /api/signin и которое хранится в куке token.
Создание докер образа
Веб-сервер написан, пришло время задуматься о деплое. В принципе приложение можно скомпилировать и без проблем запустить на другом компьютере с такой же ОС, достаточно прихватить с собой поддиректорию web с файлами фронтенда. Но почему бы не создать докер-образ и не похвастаться перед друзьями вашей итоговой работой?
В заключительном задании итогового проекта вы должны создать докер-образ с вашим веб-сервером. Это задание со звёздочкой, но мы рекомендуем всем попробовать свои силы. На проверку ревьюверам достаточно предоставить Dockerfile для создания образа, поэтому вам не обязательно регистрировать аккаунт и размещать готовый образ на hub.docker.com. При этом вы должны создать докер-образ на своём компьютере и запустить контейнер с такими параметрами, чтобы планировщик работал в браузере и подключался к SQLite базе данных на хосте, в вашей ОС. Ревьюверу вместе с Dockerfile стоит показать пример командной строки для запуска контейнера с нужными параметрами.
Вот несколько советов:
	•			В качестве базового образа можно взять ubuntu:latest;
	•			Достаточно скопировать в образ исполняемый файл и поддиректорию web;
	•			На Windows можно скачать образ golang и c помощью его скомпилировать программу для Linux;
	•			Не забудьте указать порт веб-сервера с помощью EXPOSE;
	•			Можно воспользоваться командой ENV для определения переменных окружения TODO_PORT, TODO_DBFILE, TODO_PASSWORD, если вы реализовали их поддержку.
Оформление проекта
Вы закончили написание веб-сервера и реализовали его в соответствии с техническим заданием. Тесты проходят успешно, вы готовы отправить проект ревьюверу. Не спешите. Разработчик должен не только уметь писать код, но и составлять сопутствующую документацию. Вашу работу будут проверять живые люди, и у каждого из них может быть по несколько десятков работ в очереди на проверку. Стоит облегчить их труд и включить в проект небольшой README.md файл. Добавьте в этот файл следующие пункты:
	•			Описание проекта — для чего он создан, что он делает;
	•			Список выполенных заданий со звёздочкой. Если их нет, напишите, что задания повышенной трудности не выполнялись;
	•			Инструкция по запуску кода локально: дополнительные флаги, примеры .env и так далее. Напишите, какой адрес следует указывать в браузере;
	•			Инструкция по запуску тестов. Укажите, какие параметры в tests/settings.go следует использовать;
	•			Инструкция по сборке и запуску проекта через докер — если вы это сделали;
Как видите, все требования простые, но они помогут разобраться в вашем коде и проверить работу программы.